# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Joint distribution of order statistics for the two-group case
#' 
#' Calculates, under the assumption of joint stochastic independence, the joint distribution of order statistics for the one- or two-group case.
#' 
#' Calculates, under the assumption of joint stochastic independence, the probability P(X_(1:n)<= b_1,...,X_(n:n)<= b_n)
#' where X_(i:n) denotes the i-th order statistic of the sample X_1,...,X_n and the X_k belong to two groups.
#' The first is Uni[0,1] and the seconds is given by its cdf Fn_alt. 
#' 
#' The implementation is based on a generalization of Noe's recursion. For the details see https://arxiv.org/abs/1812.09063.
#' 
#' @param b Vector of upper bounds b
#' @param Fn_alt Distribution (cdf) under the alternative
#' @param n1 The maximal size of the first group - Can be at most length(b)
#' @param n2 The maximal size of the second group - Can be at most length(b)
#' @param parallel Use parallelization to speed up the calculation?
#' @param progress Show a progress bar?
#' @param quick Use lower precision to speed up calculation?
#' 
#' @return Returns a matrix M, where M[i,j] is the above probability (for n=i-1+j-1) where (i-1) of the X_k belong to the first group
#' and (j-1) belong to the second group.
#'
#' @export
pordstat2 <- function(b, Fn_alt, n1 = -1L, n2 = -1L, parallel = TRUE, progress = TRUE, quick = FALSE) {
    .Call(`_OrdStat_pordstat2`, b, Fn_alt, n1, n2, parallel, progress, quick)
}

#' Calculates the joint density of the number discoveries R and the number of false discoveries V
#' 
#' Calculates, under the assumption of joint stochastic independence, the joint density of the number discoveries R and the number of false discoveries V of
#' an FDR controlling step-up test given by the vector of thresholds b.
#' 
#' Calculates, under the assumption
#' * of joint stochastic independence and
#' * that the p-values are Uni[0,1] under H_0 and distributed according to Fn_alt under H_1 and
#' * that exactly m0 of the m hypotheses are true
#' the joint density of the number discoveries R and the number of false discoveries V of
#' an FDR controlling step-up test given by the vector of thresholds b. This corresponds to
#' the model FM(m,m0,Fn_alt) in https://arxiv.org/abs/1812.09063.
#' 
#' The implementation is based on a generalization of Noe's recursion. For the details see https://arxiv.org/abs/1812.09063.
#' 
#' @param b Vector of upper bounds b
#' @param Fn_alt Distribution (cdf) under the alternative
#' @param m0 The number of true hypotheses - Can be at most m
#' @param m The number of hypotheses - Can be at most length(b)
#' @param parallel Use parallelization to speed up the calculation?
#' @param progress Show a progress bar?
#' @param quick Use lower precision to speed up calculation?
#' 
#' @return Returns a data.frame with three columns. The first column 'R' is the number of discoveries, the second column 'V' is the number
#' of false discoveries and the third column gives the joint probability of making exactly this number of discoveries and false discoveries.
#' 
#' @examples
#' #Equation (24) in Glueck, D., Mandel, J., Karimpour-Fard, A., et al. (2008). Exact Calculations of Average Power for the Benjamini-Hochberg Procedure. The International Journal of Biostatistics, 4(1), doi:10.2202/1557-4679.1103
#' Fn <- function(t) 1 + pnorm(qnorm(t/2)-sqrt(N)) - pnorm(qnorm(1-t/2)-sqrt(N))
#' #Setting of Table 2 of Glueck (2008)
#' N <- 5
#' m <- 5
#' m0 <- 4
#' t <- 0.05 * (1:m)/m
#' density <- OrdStat::dfd_fm(t,Fn,m0,m,progress=F)
#' #Calculate the last power value in Table 2 of Glueck (2008)
#' print(with(density,sum(p*(R-V)/(m-m0))))
#' 
#' @export
dfd_fm <- function(b, Fn_alt, m0, m, parallel = TRUE, progress = TRUE, quick = FALSE) {
    .Call(`_OrdStat_dfd_fm`, b, Fn_alt, m0, m, parallel, progress, quick)
}

#' Calculates the average power of a FDR controlling procedure
#' 
#' Calculates, under the assumption of joint stochastic independence, the average power
#' E[(R-V)/(m-m_0)] of a FDR controlling step-up test given by the vector of thresholds b.
#' 
#' Calculates, under the model FM(m,m0,Fn_alt) in https://arxiv.org/abs/1812.09063 the average power E[(R-V)/(m-m_0)].
#' For the definition of R and V see the documentation of \code{dfd_fm}.
#' 
#' The implementation is based on a generalization of Noe's recursion. For the details see https://arxiv.org/abs/1812.09063.
#' 
#' @param b Vector of upper bounds b
#' @param Fn_alt Distribution (cdf) under the alternative
#' @param m0 The number of true hypotheses - Can be at most m
#' @param m The number of hypotheses - Can be at most length(b)
#' @param parallel Use parallelization to speed up the calculation?
#' @param progress Show a progress bar?
#' @param quick Use lower precision to speed up calculation?
#' 
#' @return Returns the average power
#' 
#' @examples
#' #Equation (24) in Glueck, D., Mandel, J., Karimpour-Fard, A., et al. (2008). Exact Calculations of Average Power for the Benjamini-Hochberg Procedure. The International Journal of Biostatistics, 4(1), doi:10.2202/1557-4679.1103
#' Fn <- function(t) 1 + pnorm(qnorm(t/2)-sqrt(N)) - pnorm(qnorm(1-t/2)-sqrt(N))
#' #Setting of Table 2 of Glueck (2008)
#' N <- 5
#' m <- 5
#' m0 <- 4
#' t <- 0.05 * (1:m)/m
#' #Calculate the last power value in Table 2 of Glueck (2008)
#' print(OrdStat::avg_pwr(t,Fn,m0,m,progress=F))
#' 
#' @export
avg_pwr <- function(b, Fn_alt, m0, m, parallel = TRUE, progress = TRUE, quick = FALSE) {
    .Call(`_OrdStat_avg_pwr`, b, Fn_alt, m0, m, parallel, progress, quick)
}

#' Calculates the lambda-power of a FDR controlling procedure
#' 
#' Calculates, under the model RM(m,pr,Fn_alt) in https://arxiv.org/abs/1812.09063 the lambda-power P[(R-V)/(m-M_0)>=lambda].
#' 
#' Calculates, under the assumption of joint stochastic independence, the lambda-power
#' P[(R-V)/(m-M_0)>=lambda] of a FDR controlling step-up test given by the vector of thresholds b
#' and where M_0 is binomially distributed pbinom(.,m,pr).
#' For the definition of R and V see the documentation of \code{dfd_fm}.
#' 
#' The implementation is based on a generalization of Noe's recursion. For the details see https://arxiv.org/abs/1812.09063.
#' 
#' @param b Vector of upper bounds b
#' @param Fn_alt Distribution (cdf) under the alternative
#' @param pr The probability that a given hypothesis is true
#' @param m The number of hypotheses - Can be at most length(b)
#' @param lambda The threshold lambda
#' @param parallel Use parallelization to speed up the calculation?
#' @param progress Show a progress bar?
#' @param quick Use lower precision to speed up calculation?
#' 
#' @return Returns the lambda power
#' 
#' @examples
#' #Calculate the lambda power for the setting given by the first column in Table 3
#' # of Izmirlian, G., (2018). Average power and lambda-power in multiple testing
#' # scenarios when the benjamini-hochberg false discovery rate procedure is used. arXiv preprint arXiv:1801.03989
#' lambda <- 0.9
#' m <- 200
#' n <- 70
#' r <- 5/200
#' alpha <- 0.15
#' theta <- 0.6
#' df <- 2*n-2
#' ncp <- sqrt(n/2) * theta
#' t <- alpha * (1:m)/m
#' pr <- 1-r
#' Fn <- function(t) pt(qt(t/2,df,0,F),df,ncp,F)-pt(-qt(t/2,df,0,F),df,ncp)
#' print(OrdStat::lambda_pwr(t,Fn,pr,m,lambda))
#' 
#' @export
lambda_pwr <- function(b, Fn_alt, pr, m, lambda, parallel = TRUE, progress = TRUE, quick = FALSE) {
    .Call(`_OrdStat_lambda_pwr`, b, Fn_alt, pr, m, lambda, parallel, progress, quick)
}

